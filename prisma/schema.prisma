generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  Int                  @id @default(autoincrement())
  email               String               @unique
  password            String
  role                UserRole             @default(PROSPECT)
  name                String?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  adminReviews        AdminReview[]
  clientProfile       ClientProfile?
  coachProfile        CoachProfile?
  medias              Media[]
  messagesSent        Message[]            @relation("senderMessages")
  passwordResetTokens PasswordResetToken[]
}

model CoachProfile {
  id             Int             @id @default(autoincrement())
  userId         Int             @unique
  bio            String?
  discipline     String
  portfolio      String?
  status         ApprovalStatus  @default(PENDING)
  statusReason   String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  adminReviews   AdminReview[]
  chatsAsCoach   Chat[]          @relation("coachChats")
  user           User            @relation(fields: [userId], references: [id])
  commissionLogs CommissionLog[]
  media          Media[]
}

model ClientProfile {
  id        Int      @id @default(autoincrement())
  userId    Int      @unique
  ageRange  String?
  heightCm  Int?
  weightKg  Int?
  goals     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  chats     Chat[]   @relation("clientChats")
  user      User     @relation(fields: [userId], references: [id])
}

model Media {
  id          Int           @id @default(autoincrement())
  ownerId     Int?
  coachId     Int?
  url         String
  type        MediaType
  mimeType    String
  sizeBytes   Int?
  description String?
  createdAt   DateTime      @default(now())
  coach       CoachProfile? @relation(fields: [coachId], references: [id])
  owner       User?         @relation(fields: [ownerId], references: [id])
}

model Chat {
  id        Int           @id @default(autoincrement())
  coachId   Int
  clientId  Int
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  client    ClientProfile @relation("clientChats", fields: [clientId], references: [id])
  coach     CoachProfile  @relation("coachChats", fields: [coachId], references: [id])
  messages  Message[]

  @@index([coachId])
  @@index([clientId])
}

model Message {
  id        Int      @id @default(autoincrement())
  chatId    Int
  senderId  Int
  content   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  chat      Chat     @relation(fields: [chatId], references: [id])
  sender    User     @relation("senderMessages", fields: [senderId], references: [id])
}

model AdminReview {
  id        Int          @id @default(autoincrement())
  coachId   Int
  adminId   Int
  action    ReviewAction
  comment   String?
  createdAt DateTime     @default(now())
  admin     User         @relation(fields: [adminId], references: [id])
  coach     CoachProfile @relation(fields: [coachId], references: [id])
}

model CommissionLog {
  id        Int          @id @default(autoincrement())
  coachId   Int
  amount    Decimal      @db.Decimal(10, 2)
  reference String?
  note      String?
  createdAt DateTime     @default(now())
  coach     CoachProfile @relation(fields: [coachId], references: [id])
}

/// Stores password reset tokens for secure password recovery.
/// Tokens expire after 1 hour and are single-use.
model PasswordResetToken {
  id        Int      @id @default(autoincrement())
  userId    Int
  token     String   @unique
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([userId])
}

enum UserRole {
  PROSPECT
  COACH
  ADMIN
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum MediaType {
  CERTIFICATE
  IMAGE
  VIDEO
  OTHER
}

enum ReviewAction {
  APPROVED
  REJECTED
  PENDING
}
